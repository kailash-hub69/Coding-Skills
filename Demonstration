#include <stdio.h>
#include <stdlib.h>

#define MAX 100   // Maximum number of customers

// Structure to store customer details
typedef struct {
    int id;              // Customer ID (1,2,3,...)
    int arrivalTime;     // Time when customer arrives
    int serviceTime;     // Time required to serve the customer
    int startTime;       // Time when service actually starts
    int finishTime;      // Time when service is finished
    int waitingTime;     // startTime - arrivalTime
} Customer;

// Queue structure for simulation (FIFO)
typedef struct {
    Customer data[MAX];
    int front;
    int rear;
    int size;
} Queue;

// Queue functions
void initQueue(Queue *q) {
    q->front = 0;
    q->rear = -1;
    q->size = 0;
}

int isEmpty(Queue *q) {
    return (q->size == 0);
}

int isFull(Queue *q) {
    return (q->size == MAX);
}

void enqueue(Queue *q, Customer c) {
    if (isFull(q)) {
        printf("Queue is full! Cannot enqueue more customers.\n");
        return;
    }
    q->rear = (q->rear + 1) % MAX;
    q->data[q->rear] = c;
    q->size++;
}

Customer dequeue(Queue *q) {
    Customer dummy = {-1,0,0,0,0,0};
    if (isEmpty(q)) {
        printf("Queue is empty! Cannot dequeue.\n");
        return dummy;
    }
    Customer c = q->data[q->front];
    q->front = (q->front + 1) % MAX;
    q->size--;
    return c;
}

// Optional: sort customers by arrival time (simple bubble sort)
void sortByArrival(Customer arr[], int n) {
    int i, j;
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - 1 - i; j++) {
            if (arr[j].arrivalTime > arr[j+1].arrivalTime) {
                Customer temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

int main() {
    int n, i;
    Customer customers[MAX];
    Customer result[MAX]; // to store final details in order of service
    Queue q;
    int time = 0;         // current time in simulation
    int processed = 0;    // number of customers processed
    int index = 0;        // index for arrivals
    double totalWaitingTime = 0.0;

    printf("=== BANK CUSTOMER QUEUE SIMULATION ===\n\n");
    printf("Enter number of customers (max %d): ", MAX);
    scanf("%d", &n);

    if (n <= 0 || n > MAX) {
        printf("Invalid number of customers.\n");
        return 0;
    }

    // Input customer data
    printf("\nEnter arrival time and service time for each customer.\n");
    printf("(Assume time in minutes, starting from 0)\n\n");

    for (i = 0; i < n; i++) {
        customers[i].id = i + 1;
        printf("Customer %d:\n", customers[i].id);
        printf("  Arrival time: ");
        scanf("%d", &customers[i].arrivalTime);
        printf("  Service time: ");
        scanf("%d", &customers[i].serviceTime);
        customers[i].startTime = 0;
        customers[i].finishTime = 0;
        customers[i].waitingTime = 0;
        printf("\n");
    }

    // Sort customers by arrival time so simulation is correct
    sortByArrival(customers, n);

    // Initialize queue
    initQueue(&q);

    // Simulation loop
    // Continue until all customers are processed
    while (processed < n) {
        // Enqueue all customers who have arrived at or before current time
        while (index < n && customers[index].arrivalTime <= time) {
            enqueue(&q, customers[index]);
            index++;
        }

        if (!isEmpty(&q)) {
            // Dequeue next customer from queue (FIFO)
            Customer c = dequeue(&q);

            // If the server is idle and this customer arrived later, jump time
            if (time < c.arrivalTime) {
                time = c.arrivalTime;
            }

            c.startTime = time;
            c.waitingTime = c.startTime - c.arrivalTime;
            c.finishTime = c.startTime + c.serviceTime;

            // Move time forward to when this customer finishes
            time = c.finishTime;

            result[processed] = c;
            totalWaitingTime += c.waitingTime;
            processed++;

        } else {
            // No one in the queue, jump to next customer's arrival time
            if (index < n) {
                time = customers[index].arrivalTime;
            }
        }
    }

    // Output results
    printf("\n=== SIMULATION RESULT (BANK QUEUE) ===\n");
    printf("ID\tArrival\tService\tStart\tFinish\tWaiting\n");
    printf("--------------------------------------------------\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\n",
               result[i].id,
               result[i].arrivalTime,
               result[i].serviceTime,
               result[i].startTime,
               result[i].finishTime,
               result[i].waitingTime);
    }

    printf("--------------------------------------------------\n");
    printf("Average waiting time: %.2f minutes\n", totalWaitingTime / n);

    printf("\nInterpretation:\n");
    printf("- 'Waiting' is how long each customer waited before service.\n");
    printf("- Average waiting time shows how efficient the single counter is.\n");
    printf("- You can change arrival/service times to test different scenarios.\n");

    return 0;
}
